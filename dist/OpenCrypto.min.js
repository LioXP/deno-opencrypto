"use strict";function _instanceof(e,t){return null!=t&&"undefined"!=typeof Symbol&&t[Symbol.hasInstance]?!!t[Symbol.hasInstance](e):e instanceof t}function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function _classCallCheck(e,t){if(!_instanceof(e,t))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function _createClass(e,t,r){return t&&_defineProperties(e.prototype,t),r&&_defineProperties(e,r),e}var cryptoLib=window.crypto||window.msCrypto,cryptoApi=cryptoLib.subtle||cryptoLib.webkitSubtle,chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",lookup=new Uint8Array(256),PBES2_OID="06092a864886f70d01050d",PBKDF2_OID="06092a864886f70d01050c",AES256GCM_OID="060960864801650304012e",AES192GCM_OID="060960864801650304011a",AES128GCM_OID="0609608648016503040106",AES256CBC_OID="060960864801650304012a",AES192CBC_OID="0609608648016503040116",AES128CBC_OID="0609608648016503040102",AES256CFB_OID="060960864801650304012c",AES192CFB_OID="0609608648016503040118",AES128CFB_OID="06086086480165030404",SHA512_OID="06082a864886f70d020b0500",SHA384_OID="06082a864886f70d020a0500",SHA256_OID="06082a864886f70d02090500",SHA1_OID="06082a864886f70d02070500",RSA_OID="06092a864886f70d010101",EC_OID="06072a8648ce3d0201",P256_OID="06082a8648ce3d030107",P384_OID="06052b81040022",P521_OID="06052b81040023",OpenCrypto=function(){function t(){_classCallCheck(this,t);for(var e=0;e<chars.length;e++)lookup[chars.charCodeAt(e)]=e}return _createClass(t,[{key:"encodeAb",value:function(e){for(var t=new Uint8Array(e),r=t.length,n="",o=0;o<r;o+=3)n+=chars[t[o]>>2],n+=chars[(3&t[o])<<4|t[o+1]>>4],n+=chars[(15&t[o+1])<<2|t[o+2]>>6],n+=chars[63&t[o+2]];return r%3==2?n=n.substring(0,n.length-1)+"=":r%3==1&&(n=n.substring(0,n.length-2)+"=="),n}},{key:"decodeAb",value:function(e){var t,r,n,o,a=e.length,i=.75*e.length,p=0;"="===e[e.length-1]&&(i--,"="===e[e.length-2]&&i--);for(var s=new ArrayBuffer(i),y=new Uint8Array(s),c=0;c<a;c+=4)t=lookup[e.charCodeAt(c)],r=lookup[e.charCodeAt(c+1)],n=lookup[e.charCodeAt(c+2)],o=lookup[e.charCodeAt(c+3)],y[p++]=t<<2|r>>4,y[p++]=(15&r)<<4|n>>2,y[p++]=(3&n)<<6|63&o;return s}},{key:"arrayBufferToString",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input to be an ArrayBuffer Object");return new TextDecoder("utf-8").decode(e)}},{key:"stringToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input to be a String");return new TextEncoder("utf-8").encode(e).buffer}},{key:"arrayBufferToHexString",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input to be an ArrayBuffer Object");for(var t,r=new Uint8Array(e),n="",o=0;o<r.byteLength;o++)(t=r[o].toString(16)).length<2&&(t="0"+t),n+=t;return n}},{key:"hexStringToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input of hexString to be a String");if(e.length%2!=0)throw new RangeError("Expected string to be an even number of characters");for(var t=new Uint8Array(e.length/2),r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}},{key:"arrayBufferToBase64",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input to be an ArrayBuffer Object");return this.encodeAb(e)}},{key:"base64ToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input to be a base64 String");return this.decodeAb(e)}},{key:"decimalToHex",value:function(e,t){t=void 0!==t&&t;var r=null;return"number"==typeof e?t?(r=e.toString(16)).length%2?"000"+r:"00"+r:(r=e.toString(16)).length%2?"0"+r:r:"string"==typeof e?(r=(e.length/2).toString(16)).length%2?"0"+r:r:void 0}},{key:"addNewLines",value:function(e){for(var t="";0<e.length;)t+=e.substring(0,64)+"\r\n",e=e.substring(64);return t}},{key:"removeLines",value:function(e){return e.replace(/\r?\n|\r/g,"")}},{key:"toAsn1",value:function(e,t,r,n,o,a,i){e=this.arrayBufferToHexString(e),t=this.arrayBufferToHexString(t),r=this.arrayBufferToHexString(r),n=this.decimalToHex(n,!0);var p={};switch(o){case"SHA-512":p.HASH_OID=SHA512_OID;break;case"SHA-384":p.HASH_OID=SHA384_OID;break;case"SHA-256":p.HASH_OID=SHA256_OID;break;case"SHA-1":p.HASH_OID=SHA1_OID}switch(a){case"AES-GCM":256===i?p.CIPHER_OID=AES256GCM_OID:192===i?p.CIPHER_OID=AES192GCM_OID:128===i&&(p.CIPHER_OID=AES128GCM_OID);break;case"AES-CBC":256===i?p.CIPHER_OID=AES256CBC_OID:192===i?p.CIPHER_OID=AES192CBC_OID:128===i&&(p.CIPHER_OID=AES128CBC_OID);break;case"AES-CFB":256===i?p.CIPHER_OID=AES256CFB_OID:192===i?p.CIPHER_OID=AES192CFB_OID:128===i&&(p.CIPHER_OID=AES128CFB_OID)}var s="02"+this.decimalToHex(n.length/2)+n,y="04"+this.decimalToHex(t)+t,c="04"+this.decimalToHex(r)+r,f="04"+(this.decimalToHex(e).length/2==2?"82":"81")+this.decimalToHex(e)+e;p.SEQUENCE_AES_CONTAINER="30"+this.decimalToHex(p.CIPHER_OID+c),p.SEQUENCE_HASH_CONTAINER="30"+this.decimalToHex(p.HASH_OID),p.SEQUENCE_PBKDF2_INNER_CONTAINER="30"+this.decimalToHex(y+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBKDF2_CONTAINER="30"+this.decimalToHex(PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+y+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBES2_INNER_CONTAINER="30"+this.decimalToHex(p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+y+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+c),p.SEQUENCE_PBES2_CONTAINER="30"+this.decimalToHex(PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+y+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+c);var u=p.SEQUENCE_PBES2_CONTAINER+PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+y+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+c,h=this.decimalToHex(u+f),E="30"+(h.length/2==2?"82":"81")+h+u+f,d=this.hexStringToArrayBuffer(E),g=this.arrayBufferToBase64(d);return g="-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n"+(g=this.addNewLines(g))+"-----END ENCRYPTED PRIVATE KEY-----"}},{key:"fromAsn1",value:function(e){var t={};e=(e=(e=this.removeLines(e)).replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","")).replace("-----END ENCRYPTED PRIVATE KEY-----",""),e=this.base64ToArrayBuffer(e);var r=this.arrayBufferToHexString(e);return t.data=r,t.data.includes(PBES2_OID)&&t.data.includes(PBKDF2_OID)&&(t.valid=!0),t.saltBegin=t.data.indexOf(PBKDF2_OID)+28,t.data.includes(AES256GCM_OID)?(t.cipher="AES-GCM",t.keyLength=256,t.ivBegin=t.data.indexOf(AES256GCM_OID)+24):t.data.includes(AES192GCM_OID)?(t.cipher="AES-GCM",t.keyLength=192,t.ivBegin=t.data.indexOf(AES192GCM_OID)+24):t.data.includes(AES128GCM_OID)?(t.cipher="AES-GCM",t.keyLength=128,t.ivBegin=t.data.indexOf(AES128GCM_OID)+24):t.data.includes(AES256CBC_OID)?(t.cipher="AES-CBC",t.keyLength=256,t.ivBegin=t.data.indexOf(AES256CBC_OID)+24):t.data.includes(AES192CBC_OID)?(t.cipher="AES-CBC",t.keyLength=192,t.ivBegin=t.data.indexOf(AES192CBC_OID)+24):t.data.includes(AES128CBC_OID)?(t.cipher="AES-CBC",t.keyLength=128,t.ivBegin=t.data.indexOf(AES128CBC_OID)+24):t.data.includes(AES256CFB_OID)?(t.cipher="AES-CFB",t.keyLength=256,t.ivBegin=t.data.indexOf(AES256CFB_OID)+24):t.data.includes(AES192CFB_OID)?(t.cipher="AES-CFB",t.keyLength=192,t.ivBegin=t.data.indexOf(AES192CFB_OID)+24):t.data.includes(AES128CFB_OID)&&(t.cipher="AES-CFB",t.keyLength=128,t.ivBegin=t.data.indexOf(AES128CFB_OID)+22),t.data.includes(SHA512_OID)?t.hash="SHA-512":t.data.includes(SHA384_OID)?t.hash="SHA-384":t.data.includes(SHA256_OID)?t.hash="SHA-256":t.data.includes(SHA1_OID)&&(t.hash="SHA-1"),t.saltLength=parseInt(t.data.substr(t.saltBegin,2),16),t.ivLength=parseInt(t.data.substr(t.ivBegin,2),16),t.salt=t.data.substr(t.saltBegin+2,2*t.saltLength),t.iv=t.data.substr(t.ivBegin+2,2*t.ivLength),t.iterBegin=t.saltBegin+4+2*t.saltLength,t.iterLength=parseInt(t.data.substr(t.iterBegin,2),16),t.iter=parseInt(t.data.substr(t.iterBegin+2,2*t.iterLength),16),t.sequencePadding="81"===t.data.substr(2,2)?8:10,t.parametersPadding="81"===t.data.substr(2,2)?12:16,t.sequenceLength=parseInt(t.data.substr(t.sequencePadding,2),16),t.encryptedDataBegin=t.parametersPadding+2*t.sequenceLength,t.encryptedDataPadding="81"===t.data.substr(t.encryptedDataBegin-2,2)?2:4,t.encryptedDataLength=parseInt(t.data.substr(t.encryptedDataBegin,6),16),t.encryptedData=t.data.substr(t.encryptedDataBegin+t.encryptedDataPadding,2*t.encryptedDataLength),{salt:this.hexStringToArrayBuffer(t.salt),iv:this.hexStringToArrayBuffer(t.iv),cipher:t.cipher,keyLength:t.keyLength,hash:t.hash,iter:t.iter,encryptedData:this.hexStringToArrayBuffer(t.encryptedData)}}},{key:"cryptoPrivateToPem",value:function(e){var o=this;return new Promise(function(n,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("pkcs8",e).then(function(e){var t=o.arrayBufferToBase64(e),r=o.addNewLines(t);n(r="-----BEGIN PRIVATE KEY-----\r\n"+r+"-----END PRIVATE KEY-----")}).catch(function(e){t(e)})})}},{key:"pemPrivateToCrypto",value:function(p,s){var y=this;return new Promise(function(t,r){if(void 0===s&&(s={}),s.isExtractable=void 0===s.isExtractable||s.isExtractable,"string"!=typeof p)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof s.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a String");p=(p=p.replace("-----BEGIN PRIVATE KEY-----","")).replace("-----END PRIVATE KEY-----","");var e=y.removeLines(p),n=y.base64ToArrayBuffer(e),o=y.arrayBufferToHexString(n),a=null;if(o.includes(EC_OID)){if(s.name=void 0!==s.name?s.name:"ECDH","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");var i=null;if(o.includes(P256_OID)?i="P-256":o.includes(P384_OID)?i="P-384":o.includes(P521_OID)&&(i="P-521"),"ECDH"===s.name){if(s.usages=void 0!==s.usages?s.usages:["deriveKey","deriveBits"],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be a String")}else{if("ECDSA"!==s.name)throw new TypeError("Invalid algorithm name");if(s.usages=void 0!==s.usages?s.usages:["sign"],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be a String")}a={name:s.name,namedCurve:i}}else{if(!o.includes(RSA_OID))throw new TypeError("Invalid private key");if(s.name=void 0!==s.name?s.name:"RSA-OAEP",s.hash=void 0!==s.hash?s.hash:"SHA-512","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof s.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===s.name){if(s.usages=void 0!==s.usages?s.usages:["decrypt","unwrapKey"],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be an Array")}else{if("RSA-PSS"!==s.name)throw new TypeError("Invalid algorithm name");if(s.usages=void 0!==s.usages?s.usages:["sign"],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be a String")}a={name:s.name,hash:{name:s.hash}}}cryptoApi.importKey("pkcs8",n,a,s.isExtractable,s.usages).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"cryptoPublicToPem",value:function(e){var o=this;return new Promise(function(n,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("spki",e).then(function(e){var t=o.arrayBufferToBase64(e),r=o.addNewLines(t);n(r="-----BEGIN PUBLIC KEY-----\r\n"+r+"-----END PUBLIC KEY-----")}).catch(function(e){t(e)})})}},{key:"pemPublicToCrypto",value:function(p,s){var y=this;return new Promise(function(t,r){if(void 0===s&&(s={}),s.isExtractable=void 0===s.isExtractable||s.isExtractable,"string"!=typeof p)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof s.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a String");p=(p=p.replace("-----BEGIN PUBLIC KEY-----","")).replace("-----END PUBLIC KEY-----","");var e=y.removeLines(p),n=y.base64ToArrayBuffer(e),o=y.arrayBufferToHexString(n),a=null;if(o.includes(EC_OID)){if(s.name=void 0!==s.name?s.name:"ECDH","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");var i=null;if(o.includes(P256_OID)?i="P-256":o.includes(P384_OID)?i="P-384":o.includes(P521_OID)&&(i="P-521"),"ECDH"===s.name){if(s.usages=void 0!==s.usages?s.usages:[],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be a String")}else{if("ECDSA"!==s.name)throw new TypeError("Invalid algorithm name");if(s.usages=void 0!==s.usages?s.usages:["verify"],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be a String")}a={name:s.name,namedCurve:i}}else{if(!o.includes(RSA_OID))throw new TypeError("Invalid public key");if(s.name=void 0!==s.name?s.name:"RSA-OAEP",s.hash=void 0!==s.hash?s.hash:"SHA-512","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof s.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===s.name){if(s.usages=void 0!==s.usages?s.usages:["encrypt","wrapKey"],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be an Array")}else{if("RSA-PSS"!==s.name)throw new TypeError("Invalid algorithm name");if(s.usages=void 0!==s.usages?s.usages:["verify"],"object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be an Array")}a={name:s.name,hash:{name:s.hash}}}cryptoApi.importKey("spki",n,a,s.isExtractable,s.usages).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"getRSAKeyPair",value:function(e,n,o,a,i){return e=void 0!==e?e:2048,n=void 0!==n?n:"SHA-512",o=void 0!==o?o:"RSA-OAEP",a=void 0!==a?a:["encrypt","decrypt","wrapKey","unwrapKey"],i=void 0===i||i,new Promise(function(t,r){if("number"!=typeof e)throw new TypeError("Expected input of modulusLength to be a Number");if("string"!=typeof n)throw new TypeError("Expected input of hash expected to be a String");if("string"!=typeof o)throw new TypeError("Expected input of paddingScheme to be a String");if("object"!==_typeof(a))throw new TypeError("Expected input of usages to be an Array");if("boolean"!=typeof i)throw new TypeError("Expected input of isExtractable to be a Boolean");cryptoApi.generateKey({name:o,modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:n}},i,a).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"rsaEncrypt",value:function(e,n){var o=this;return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type public");if("object"!==_typeof(n))throw new TypeError("Expected input of data to be an ArrayBuffer");cryptoApi.encrypt({name:"RSA-OAEP"},e,n).then(function(e){t(o.arrayBufferToBase64(e))}).catch(function(e){r(e)})})}},{key:"rsaDecrypt",value:function(e,n){var o=this;return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type private");if("string"!=typeof n)throw new TypeError("Expected input of encryptedData to be a String");cryptoApi.decrypt({name:"RSA-OAEP"},e,o.base64ToArrayBuffer(n)).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"getECKeyPair",value:function(e,n,o,a){return e=void 0!==e?e:"P-256",n=void 0!==n?n:"ECDH",o=void 0!==o?o:["deriveKey","deriveBits"],a=void 0===a||a,new Promise(function(t,r){if("string"!=typeof e)throw new TypeError("Expected input of curve to be a String");if("string"!=typeof n)throw new TypeError("Expected input of type to be a String");if("object"!==_typeof(o))throw new TypeError("Expected input of usages to be an Array");if("boolean"!=typeof a)throw new TypeError("Expected input of isExtractable to be a Boolean");cryptoApi.generateKey({name:n,namedCurve:e},a,o).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"encryptPrivateKey",value:function(a,i,p,s,y,c){var f=this;return p=void 0!==p?p:64e3,s=void 0!==s?s:"SHA-512",y=void 0!==y?y:"AES-GCM",c=void 0!==c?c:256,new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"private"!==a.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object");if("string"!=typeof i)throw new TypeError("Expected input of passphrase to be a String");if("number"!=typeof p)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof s)throw new TypeError("Expected input of hash to be a String");if("string"!=typeof y)throw new TypeError("Expected input of cipher to be a String");if("number"!=typeof c)throw new TypeError("Expected input of keyLength to be a Number");var e=null;"AES-GCM"===y?e=12:"AES-CBC"!==y&&"AES-CFB"!==y||(e=16);var n=cryptoLib.getRandomValues(new Uint8Array(16)),o=cryptoLib.getRandomValues(new Uint8Array(e));cryptoApi.importKey("raw",f.stringToArrayBuffer(i),{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:n,iterations:p,hash:s},e,{name:y,length:c},!0,["wrapKey"]).then(function(e){cryptoApi.wrapKey("pkcs8",a,e,{name:y,iv:o,tagLength:128}).then(function(e){var t=f.toAsn1(e,n,o,p,s,y,c);r(t)}).catch(function(e){t(e)})}).catch(function(e){t(e)})}).catch(function(e){t(e)})})}},{key:"decryptPrivateKey",value:function(e,o,a){var i=this,p=this.fromAsn1(e);return new Promise(function(t,r){void 0===a&&(a={});var n={};if(a.name=void 0!==a.name?a.name:"ECDH",a.isExtractable=void 0===a.isExtractable||a.isExtractable,n.name=a.name,"ECDH"===a.name){if(a.namedCurve=void 0!==a.namedCurve?a.namedCurve:"P-256",a.keyUsages=void 0!==a.keyUsages?a.keyUsages:["deriveKey","deriveBits"],n.namedCurve=a.namedCurve,"string"!=typeof a.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a base64 String")}else if("ECDSA"===a.name){if(a.namedCurve=void 0!==a.namedCurve?a.namedCurve:"P-256",a.keyUsages=void 0!==a.keyUsages?a.keyUsages:["sign"],n.namedCurve=a.namedCurve,"string"!=typeof a.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a base64 String")}else if("RSA-OAEP"===a.name){if(a.hash=void 0!==a.hash?a.hash:{},a.hash.name=void 0!==a.hash.name?a.hash.name:"SHA-512",a.keyUsages=void 0!==a.keyUsages?a.keyUsages:["decrypt","unwrapKey"],n.hash={},n.hash.name=a.hash.name,"string"!=typeof a.hash.name)throw new TypeError("Expected input of options.hash.name to be a base64 String")}else{if("RSA-PSS"!==a.name)throw new TypeError("Unsupported encryptedPrivateKey");if(a.hash=void 0!==a.hash?a.hash:{},a.hash.name=void 0!==a.hash.name?a.hash.name:"SHA-512",a.keyUsages=void 0!==a.keyUsages?a.keyUsages:["sign"],n.hash={},n.hash.name=a.hash.name,"string"!=typeof a.hash.name)throw new TypeError("Expected input of options.hash.name to be a base64 String")}if("string"!=typeof e)throw new TypeError("Expected input of encryptedPrivateKey to be a base64 String");if("string"!=typeof o)throw new TypeError("Expected input of passphrase to be a String");if("object"!==_typeof(a.keyUsages))throw new TypeError("Expected input of options.keyUsages to be a String");if("boolean"!=typeof a.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.importKey("raw",i.stringToArrayBuffer(o),{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:p.salt,iterations:p.iter,hash:p.hash},e,{name:p.cipher,length:p.keyLength},!1,["unwrapKey"]).then(function(e){cryptoApi.unwrapKey("pkcs8",p.encryptedData,e,{name:p.cipher,iv:p.iv,tagLength:128},n,a.isExtractable,a.keyUsages).then(function(e){t(e)}).catch(function(e){r(e)})}).catch(function(e){r(e)})}).catch(function(e){r(e)})})}},{key:"keyAgreement",value:function(e,n,o){return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(n)&&"public"!==n.type)throw new TypeError("Expected input of publicKey to be a CryptoKey of type public");if(void 0===o&&(o={}),o.bitLength=void 0!==o.bitLength?o.bitLength:256,o.hkdfHash=void 0!==o.hkdfHash?o.hkdfHash:"SHA-512",o.hkdfSalt=void 0!==o.hkdfSalt?o.hkdfSalt:new Uint8Array,o.hkdfInfo=void 0!==o.hkdfInfo?o.hkdfInfo:new Uint8Array,o.keyCipher=void 0!==o.keyCipher?o.keyCipher:"AES-GCM",o.keyLength=void 0!==o.keyLength?o.keyLength:256,o.keyUsages=void 0!==o.keyUsages?o.keyUsages:["encrypt","decrypt","unwrapKey","wrapKey"],o.isExtractable=void 0===o.isExtractable||o.isExtractable,"number"!=typeof o.bitLength)throw new TypeError("Expected input of options.bitLength to be a Number");if("string"!=typeof o.hkdfHash)throw new TypeError("Expected input of options.hkdfHash to be a String");if("object"!==_typeof(o.hkdfSalt))throw new TypeError("Expected input of options.hkdfSalt to be an ArrayBuffer");if("object"!==_typeof(o.hkdfInfo))throw new TypeError("Expected input of options.hkdfInfo to be an ArrayBuffer");if("string"!=typeof o.keyCipher)throw new TypeError("Expected input of options.keyCipher to be a String");if("number"!=typeof o.keyLength)throw new TypeError("Expected input of options.keyLength to be a Number");if("object"!==_typeof(o.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof o.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.deriveBits({name:"ECDH",namedCurve:n.algorithm.namedCurve,public:n},e,o.bitLength).then(function(e){cryptoApi.importKey("raw",e,{name:"HKDF"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"HKDF",hash:{name:o.hkdfHash},salt:o.hkdfSalt,info:o.hkdfInfo},e,{name:o.keyCipher,length:o.keyLength},o.isExtractable,o.keyUsages).then(function(e){t(e)}).catch(function(e){r(e)})}).catch(function(e){r(e)})}).catch(function(e){r(e)})})}},{key:"encryptKey",value:function(e,o){var a=this;return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of wrappingKey to be a CryptoKey");if("[object CryptoKey]"!==Object.prototype.toString.call(o)&&"secret"!==o.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey of type secret");if("secret"===e.type){var n=null,n="AES-GCM"===e.algorithm.name?cryptoLib.getRandomValues(new Uint8Array(12)):cryptoLib.getRandomValues(new Uint8Array(16));cryptoApi.wrapKey("raw",o,e,{name:e.algorithm.name,iv:n,tagLength:128}).then(function(e){t(a.arrayBufferToBase64(n)+a.arrayBufferToBase64(e))}).catch(function(e){r(e)})}else{if("RSA-OAEP"!==e.algorithm.name)throw new TypeError("Unsupported wrappingKey");if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of wrappingKey using RSA-OAEP to be a CryptoKey of type public");cryptoApi.wrapKey("raw",o,e,{name:"RSA-OAEP",hash:{name:e.algorithm.hash.name}}).then(function(e){t(a.arrayBufferToBase64(e))}).catch(function(e){r(e)})}})}},{key:"decryptKey",value:function(p,s,y){var c=this;return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(p))throw new TypeError("Expected input of unwrappingKey to be a CryptoKey");if("string"!=typeof s)throw new TypeError("Expected input of encryptedSharedKey to be a base64 String");if(void 0===y&&(y={}),y.keyCipher=void 0!==y.keyCipher?y.keyCipher:"AES-GCM",y.keyLength=void 0!==y.keyLength?y.keyLength:256,y.keyUsages=void 0!==y.keyUsages?y.keyUsages:["encrypt","decrypt","wrapKey","unwrapKey"],y.isExtractable=void 0===y.isExtractable||y.isExtractable,"string"!=typeof y.keyCipher)throw new TypeError("Expected input of options.keyCipher to be a String");if("number"!=typeof y.keyLength)throw new TypeError("Expected input of options.keyLength to be a Number");if("object"!==_typeof(y.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof y.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");if("secret"===p.type){var e=null,n=null,n="AES-GCM"===p.algorithm.name?(e=s.substring(0,16),s.substring(16)):(e=s.substring(0,24),s.substring(24)),o=c.base64ToArrayBuffer(e),a=c.base64ToArrayBuffer(n);cryptoApi.unwrapKey("raw",a,p,{name:p.algorithm.name,iv:o,tagLength:128},{name:y.keyCipher,length:y.keyLength},y.isExtractable,y.keyUsages).then(function(e){t(e)}).catch(function(e){r(e)})}else{if("RSA-OAEP"!==p.algorithm.name)throw new TypeError("Unsupported unwrappingKey");if("[object CryptoKey]"!==Object.prototype.toString.call(p)&&"private"!==p.type)throw new TypeError("Expected input of unwrappingKey to be a CryptoKey of type private");var i=c.base64ToArrayBuffer(s);cryptoApi.unwrapKey("raw",i,p,{name:"RSA-OAEP",modulusLength:p.algorithm.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:p.algorithm.hash.name}},{name:y.keyCipher,length:y.keyLength},y.isExtractable,y.keyUsages).then(function(e){t(e)}).catch(function(e){r(e)})}})}},{key:"sign",value:function(e,n,o){var a=this;return new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object");if("object"!==_typeof(n))throw new TypeError("Expected input of data to be an ArrayBuffer");if(void 0===o&&(o={}),"ECDSA"===e.algorithm.name){if(o.hash=void 0!==o.hash?o.hash:"SHA-512","string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.sign({name:"ECDSA",hash:{name:o.hash}},e,n).then(function(e){var t=a.arrayBufferToBase64(e);r(t)})}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Unsupported privateKey");if(o.saltLength=void 0!==o.saltLength?o.saltLength:128,"number"!=typeof o.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");cryptoApi.sign({name:"RSA-PSS",saltLength:o.saltLength},e,n).then(function(e){var t=a.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})}})}},{key:"verify",value:function(n,o,a,i){var p=this;return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(n)&&"public"!==n.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object");if("object"!==_typeof(o))throw new TypeError("Expected input of data to be an ArrayBuffer");if("string"!=typeof a)throw new TypeError("Expected input of signature to be a base64 String");void 0===i&&(i={});var e=p.base64ToArrayBuffer(a);if("ECDSA"===n.algorithm.name){if(i.hash=void 0!==i.hash?i.hash:"SHA-512","string"!=typeof i.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.verify({name:"ECDSA",hash:{name:i.hash}},n,e,o).then(function(e){t(e)}).catch(function(e){r(e)})}else{if("RSA-PSS"!==n.algorithm.name)throw new TypeError("Unsupported publicKey");cryptoApi.verify({name:"RSA-PSS",saltLength:128},n,e,o).then(function(e){t(e)}).catch(function(e){r(e)})}})}},{key:"getSharedKey",value:function(e,n){if("number"!=typeof(e=void 0!==e?e:256))throw new TypeError("Expected input of keyLength to be a Number");return new Promise(function(t,r){if(void 0===n&&(n={}),n.keyCipher=void 0!==n.keyCipher?n.keyCipher:"AES-GCM",n.keyUsages=void 0!==n.keyUsages?n.keyUsages:["encrypt","decrypt","wrapKey","unwrapKey"],n.isExtractable=void 0===n.isExtractable||n.isExtractable,"string"!=typeof n.keyCipher)throw new TypeError("Expected input of options.keyCipher expected to be a String");if("object"!==_typeof(n.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof n.isExtractable)throw new TypeError("Expected input of options.isExtractable expected to be a Boolean");cryptoApi.generateKey({name:n.keyCipher,length:e},n.isExtractable,n.keyUsages).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"encrypt",value:function(e,r){var a=this;return new Promise(function(n,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("object"!==_typeof(r))throw new TypeError("Expected input of data to be an ArrayBuffer");var o=cryptoLib.getRandomValues(new Uint8Array(12));cryptoApi.encrypt({name:"AES-GCM",iv:o,tagLength:128},e,r).then(function(e){var t=a.arrayBufferToBase64(o),r=a.arrayBufferToBase64(e);n(t+r)}).catch(function(e){t(e)})})}},{key:"decrypt",value:function(i,p){var s=this;return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(i)&&"secret"!==i.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("string"!=typeof p)throw new TypeError("Expected input of encryptedData to be a String");var e=p.substring(0,16),n=p.substring(16),o=s.base64ToArrayBuffer(e),a=s.base64ToArrayBuffer(n);cryptoApi.decrypt({name:"AES-GCM",iv:o,tagLength:128},i,a).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"hashPassphrase",value:function(e,n,o,a,i){var p=this;return o=void 0!==o?o:64e3,a=void 0!==a?a:"SHA-512",i=void 0!==i?i:256,new Promise(function(t,r){if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("object"!==_typeof(n))throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof o)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof a)throw new TypeError("Expected input of hash to be a String");if("number"!=typeof i)throw new TypeError("Expected input of length to be a Number");cryptoApi.importKey("raw",p.stringToArrayBuffer(e),{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:n,iterations:o,hash:a},e,{name:"AES-GCM",length:i},!0,["encrypt","decrypt"]).then(function(e){cryptoApi.exportKey("raw",e).then(function(e){t(p.arrayBufferToHexString(e))}).catch(function(e){r(e)})}).catch(function(e){r(e)})}).catch(function(e){r(e)})})}},{key:"derivePassphraseKey",value:function(e,n,o,a,i){var p=this;return o=void 0!==o?o:64e3,a=void 0!==a?a:"SHA-512",i=void 0!==i?i:256,new Promise(function(t,r){if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("object"!==_typeof(n))throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof o)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof a)throw new TypeError("Expected input of hash to be a String");if("number"!=typeof i)throw new TypeError("Expected input of length to be a Number");cryptoApi.importKey("raw",p.stringToArrayBuffer(e),{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:n,iterations:o,hash:a},e,{name:"AES-GCM",length:i},!0,["encrypt","decrypt","wrapKey","unwrapKey"]).then(function(e){t(e)}).catch(function(e){r(e)})}).catch(function(e){r(e)})})}},{key:"getFingerprint",value:function(n,o){var a=this;return new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(n))throw new TypeError("Expected input of key to be a CryptoKey Object");if(void 0===o&&(o={}),o.hash="undefined"!=typeof hash?hash:"SHA-512",o.isBuffer=void 0!==o.isBuffer&&o.isBuffer,"string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");if("boolean"!=typeof o.isBuffer)throw new TypeError("Expected input of options.isBuffer to be a Boolean");var e=null;if("public"===n.type)e="spki";else if("private"===n.type)e="pkcs8";else{if("secret"!==n.type)throw new TypeError("Expected input of key is not a valid CryptoKey");e="raw"}cryptoApi.exportKey(e,n).then(function(e){cryptoApi.digest({name:o.hash},e).then(function(e){var t;o.isBuffer?r(e):(t=a.arrayBufferToHexString(e),r(t))}).catch(function(e){t(e)})}).catch(function(e){t(e)})})}},{key:"getRandomBytes",value:function(r){return r=void 0!==r?r:16,new Promise(function(e,t){if("number"!=typeof r)throw new TypeError("Expected input of size to be a Number");e(cryptoLib.getRandomValues(new Uint8Array(r)))})}}]),t}();